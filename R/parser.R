#' Parser de notas taquigráficas do Senado
#'

#' All brazilian parties
#'
#' The names of parties used to extract the data of the column "partido"
#' Estes nomes serão usados para construir a coluna "partido"
#'
#' @examples
#' TodosPartidos
#'
#' @export
TodosPartidos <- "data/partidos.txt" |> read.table() |> unlist() |> unique() |> as.vector()


siglas.estados <- "\\b(AC|AL|AP|AM|BA|CE|DF|ES|GO|MA|MT|MS|MG|PA|PB|PR|PE|PI|RJ|RN|RS|RO|RR|SC|SP|SE|TO)\\b"

#' from html to dataframe with text
#'
#' @description
#' turns the pure html text of the tacquigraphic notes, into
#' an structured tibble/ data.frame with two columns: title and text. The results
#' from this function is send further to the parser function
#'
#' @param html_page the pure html text of the tacquigraphic notes. It can be the
#' html text as well as the "xml_document". It does not accept the URL as input
#' 
#' file_html <- list.files("inst/extdata/", full.names = TRUE)
#' NT_html <- xml2::read_html(file_html,encoding = "utf8")
#' from_html_2_df(NT_html)
from_html_2_df <- function(html_page) {
# html_page = NT_html 

  # NT_html |> 
  text <- html_page |> 
    as.character() |>
    gsub(x=_, "(<b>)", "<break_line>\\1") |>
    paste(collapse = " ") |>
    xml2::read_html(encoding = "utf8") |>
    rvest::html_elements("break_line") |>
    rvest::html_text()

  # transform data type of input
  if (typeof(html_page) == "character") {
    html_page <- xml2::read_html(
      paste(html_page, collapse = " "), 
      encoding = "utf8")
  }

  # NT_html |> 
  title <- html_page |> 
      rvest::html_elements("h1") |> 
      rvest::html_text() |> 
      grep("\\d+/\\d+", x=_, value = TRUE)

  tibble::tibble(title, text) 
}


#' extract metadata from text column from dataframe
#'
#' input is DF generated by from_html_2_df(), export a DF with more columns
#'
#' @param DF the dataframe generated by from_html_2_df
#' 
#' @export
#'
#' @examples
#' file_html <- list.files("inst/extdata/", full.names=TRUE)
#' NT_html <- xml2::read_html(file_html,encoding = "utf8")
#' extract_metadata(NT_html)
extract_metadata <- function(DF) {
 # DF <- from_html_2_df(NT_html)
  # DF <-  test_files_list[[1]] |> extract_metadata() 

  DF <- from_html_2_df(DF)
  
  DF2 <- DF |> # dplyr::select(text) |> 
    dplyr::mutate(
      metadata = text |> 
        substring(1,300) |> 
        stringr::str_extract_all( rgx_metaData, simplify = TRUE) |>
        stringr::str_extract_all( ".*\\)", simplify = TRUE),
      gentilic = metadata |>
        substring(1,10) |> 
        stringr::str_extract_all( "([sSdD][Rr][aA]?)", simplify = TRUE),
      speaker = metadata |>
        gsub(x=_,"^[OAoa] [SsRr]{2}[aA]?[\\. ]+","") |> # erase "O SR" at the beginning
        gsub(x=_, " +\\(.*", ""),
      metadata2 = metadata |> # metadata inside parenthesis, e.g,: "("Dr. Hiran. Bloco Parlamentar Aliança/PP - RR)"
        stringr::str_extract_all("\\(.*\\)", simplify = TRUE) |>
         # stringr::str_remove_all( "\\\\(")
        gsub(x=_, r"([\(\)])", ""),
      party_UF = metadata2 |>
        stringr::str_extract_all("\\W\\w+ \\W [A-Z]{2}", simplify = TRUE) |> 
        gsub(x=_,"\\/", ""),
      party = party_UF |> 
        gsub(x=_, "(\\w*)[\\W -]+.*[A-Z]{2}", "\\1" ),
      state =  party_UF |> 
        gsub(x=_, "(\\w*)[\\W -]+.*([A-Z]{2})", "\\2"),
      block = metadata2 |> 
        # gsub(x=_, "^([A-Za-z ]+)[\\/\\-].*", "\\1")
        gsub(x=_, "^(.*)\\/.*", "\\1")
  ) |> 
    dplyr::select(-party_UF, -metadata2)  |>  
     dplyr::select(title, speaker, gentilic, party, state, block, 
      metadata, text)

# when speaker is president, change columns
  DF2 |> # dplyr::pull(block)
    dplyr::mutate(
      is_chef = grepl("PRESIDENT", x = speaker),
      role = ifelse(is_chef, speaker, "" ),
      speaker = ifelse(is_chef, 
        {gsub(x=block, "(.*) Bloco.*", "\\1")} ,
        speaker),
      block = gsub(x=block,"(.*)((Bloco|BLOCO).*)", "\\2")
    ) |> dplyr::select(-is_chef)

}




#' parse the tacquigraphic notes text
#'
#' turns the pure html text of the tacquigraphic notes, into
#' an structured tibble/ data.frame, and saves it in .rds and .csv
#'
#' @param DF the dataframe generated with meetings()
#' @param linha number of the line of the dataframe generated with meetings()
#' @param save = FALSE (default). To save the files in .rds and .csv.
#'
#' @examples
#' df <- meetings(cod = "2606", start = "2023-05-25")
#' parser( df, 1 )
#'
#' @export
parser <- function(DF, linha, save = FALSE){

  cod <- attr(DF, "cod")

  message('Processing ',
          "cod:", cod,
          ", meeting: ", DF[linha, 2],
          ', "', DF[linha,3] ,
          "\", from the URL: \"",DF[linha, 4],"\"")

  url_atual <- DF[linha, 'link'] %>% as.character()

  # carregando o conteúdo da url numa variável, dentro do R
  NT_html <- url_atual %>% rvest::read_html(., encoding = "utf8")

  # texto da pagina
  texto <- NT_html %>% rvest::html_nodes('.escriba-jq') %>% rvest::html_text()
  alerta <- NT_html %>% rvest::html_element('.alert') %>% rvest::html_text()

  texto_vetores0 = gsub('[0-9]{2}\\:[0-9]{2}  R|\\(Pausa\\.\\)', '', texto) %>%
    gsub('(O SR|A SRA)\\.', 'ZZZVECTOR_\\1\\.', .) %>% strsplit(. , "ZZZVECTOR_") %>% unlist()

  # limpando a linha 1, se ela contiver o indesejável texto abaixo (sempre vem)
  reuniao <- texto_vetores0[1] %>% gsub(".* ([0-9]+)ª.*", "\\1",.)
  regex.1linha <- "\n\n+.*@import.*Texto com revisão +"

  if (grepl(regex.1linha, texto_vetores0[1])){
    texto_vetores = texto_vetores0[-1]
  } else {
    texto_vetores = texto_vetores0
  }

  ExpReg <- '(O SR|A SRA)\\. ([A-ZÀ-Ÿ \\.]+)(\\(.*?\\)| ?)([-   ––]{3})(.*)'
  vetor_nomes <- unlist(str_extract_all(texto_vetores, ExpReg))
  nome <- gsub(ExpReg,'\\2', texto_vetores) %>% gsub(' $','',.)
  # unique(nome)
  funcao_bloco = gsub(ExpReg,'\\3', texto_vetores)
  fala <- gsub(ExpReg,'\\5', texto_vetores)

  cargo_funcao = gsub(ExpReg,'\\3', texto_vetores)

  # regex com todos os partidos
  TodosPartidosER <- TodosPartidos %>% paste(collapse = "|") %>% paste0("\\b(", ., ")\\b")

  regex.bloco <- paste0(".*([Bb]loco.*[Pp]arlamentar.*)\\/(",TodosPartidosER,") - ", siglas.estados, "(.*)")
  BlocoParl <- gsub(regex.bloco,"\\1",cargo_funcao)

  complemento <- gsub(paste0(".*", siglas.estados, "(.*)"),"\\2", funcao_bloco) %>% gsub("\\.|)","",.) %>% str_trim

  NotasTaq_db <- tibble::tibble(reuniao, data = DF$data[linha], Nome = nome, funcao_bloco, BlocoParl, complemento, fala)
  # Trocando nome por nome - função
  regex.nome = "\\((.*?)\\..*"

  # 'Presidente' aparece na coluna 'nome'. vamos colocá-lo na coluna 'funcao_bloco'
  NTDB <- NotasTaq_db %>%
    dplyr::mutate(nome = ifelse(Nome == "PRESIDENTE", funcao_bloco, Nome), .before = Nome) %>%
    dplyr::mutate(funcao_blocoPar = ifelse(Nome == "PRESIDENTE", Nome, funcao_bloco), .before = funcao_bloco) %>%
    dplyr::select(!c(Nome, funcao_bloco)) %>%
    # limpando: pegando apenas o nome na var nome, deixando de fora partido, bloco parlamentar e estado
    dplyr::mutate(nome = gsub(regex.nome, "\\1",nome)) %>%
    dplyr::mutate(estado = stringr::str_extract(BlocoParl, siglas.estados ), .after = BlocoParl) %>%
    dplyr::mutate(partido = stringr::str_extract(BlocoParl, TodosPartidosER), .before = estado)


  if (save) {  ## Salvando csv rds rdata
        nomearq = paste0("NT_",DF[linha,]$reuniao_dia, "-", DF[linha,]$Depoente.tema) %>% gsub("ª|,", "",.) %>% gsub(" - ", "-", .) %>% gsub(" ", "_",.)

        dir.create(paste0(getwd(),"/", cod, "/rds"), recursive = T, showWarnings = F)
        dir.create(paste0(getwd(), "/", cod, "/csv"),  recursive = T, showWarnings = F)

        # dir.create(paste0(getwd(),"/", cod, "/rds"), recursive = T, showWarnings = F)
        write.csv(NTDB, paste0( cod, "/csv/", nomearq, ".csv"))
        saveRDS(NTDB, paste0(cod, "/rds/", nomearq, ".Rds"))
        # save(NTDB, paste0("rdata/","NT_", nomearq, ".Rdata"))
  }

  NTDB
}

